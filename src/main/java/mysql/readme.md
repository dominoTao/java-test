 开启事务
 # START TRANSACTION;
    > SELECT * FROM mytable WHERE id = '11';

    > UPDATE a set price=1000 WHERE name1='123';
 
    > UPDATE b set price=1000 WHERE name2='132';
 提交事务
 # COMMIT;
 回滚事务
 # ROLLBACK
 
 
 # 事务的ACID特性：
 事务具有4个特征，分别是原子性、一致性、隔离性和持久性，简称事务的ACID特性；
 
 ##  一、原子性（atomicity)
 
 一个事务要么全部提交成功，要么全部失败回滚，不能只执行其中的一部分操作，这就是事务的原子性
 
 ##  二、一致性（consistency)
 
 事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。
 
 如果数据库系统在运行过程中发生故障，有些事务尚未完成就被迫中断，这些未完成的事务对数据库所作的修改有一部分已写入物理数据库，这是数据库就处于一种不正确的状态，也就是不一致的状态
 
 ##  三、隔离性（isolation）
 
 事务的隔离性是指在并发环境中，并发的事务时相互隔离的，一个事务的执行不能不被其他事务干扰。不同的事务并发操作相同的数据时，每个事务都有各自完成的数据空间，即一个事务内部的操作及使用的数据对其他并发事务时隔离的，并发执行的各个事务之间不能相互干扰。
 
 在标准SQL规范中，定义了4个事务隔离级别，不同的隔离级别对事务的处理不同，分别是：未授权读取，授权读取，可重复读取和串行化
 
 #### 1、读未提交（Read Uncommited），
 该隔离级别允许脏读取，其隔离级别最低；比如事务A和事务B同时进行，事务A在整个执行阶段，会将某数据的值从1开始一直加到10，然后进行事务提交，此时，事务B能够看到这个数据项在事务A操作过程中的所有中间值（如1变成2，2变成3等），而对这一系列的中间值的读取就是未授权读取
 
 #### 2、授权读取也称为已提交读（Read Commited），
 授权读取只允许获取已经提交的数据。比如事务A和事务B同时进行，事务A进行+1操作，此时，事务B无法看到这个数据项在事务A操作过程中的所有中间值，只能看到最终的10。另外，如果说有一个事务C，和事务A进行非常类似的操作，只是事务C是将数据项从10加到20，此时事务B也同样可以读取到20，即授权读取允许不可重复读取。
 
 #### 3、可重复读（Repeatable Read)
 
 就是保证在事务处理过程中，多次读取同一个数据时，其值都和事务开始时刻是一致的，因此该事务级别禁止不可重复读取和脏读取，但是有可能出现幻影数据。所谓幻影数据，就是指同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果。在上面的例子中，可重复读取隔离级别能够保证事务B在第一次事务操作过程中，始终对数据项读取到1，但是在下一次事务操作中，即使事务B（注意，事务名字虽然相同，但是指的是另一个事务操作）采用同样的查询方式，就可能读取到10或20；
 
 #### 4、串行化
 
 是最严格的事务隔离级别，它要求所有事务被串行执行，即事务只能一个接一个的进行处理，不能并发执行。
 
 ##  四、持久性（durability）
 
 一旦事务提交，那么它对数据库中的对应数据的状态的变更就会永久保存到数据库中。--即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束的状态
 
 # MySql中的事务
 mysql提供了两种事务型存储引擎：InnoDB和NDB Cluster
 自动提交（AUTOCOMMIT）
 Mysql默认采用自动提交模式
 如果不是显式地开始一个事务，则每个查询都被当做一个事务执行提交操作。
 ## SHOW VARIABLES LIKE 'AUTOCOMMIT';
 
 1或者ON表示启用，0或者OFF表示禁用。
 
 AUTOCOMMIT=0的时候，所有的查询都是在一个事务中，知道显式执行COMMIT或者ROLLBACK，该事务结束，同时又开始了一个新事务。
 
 
 # 事务的四种隔离级别：
 InnoDB支持所有隔离级别
 ## READ UNCOMMITTED   未提交读
 事务中的修改，在提交之前，对其他事务是可见的。事务可以读取到未提交的事务，叫脏读。
 ## READ COMMITTED     提交读
 多数数据库默认隔离级别。
 不会发生脏读，一个事务不可见未提交的数据，只能看见已经提交过的数据。
 因为两次执行同样的查询，可能会得到不一样的结果，又叫不可重读。
 ## REPEATABLE READ    可重复读
 MySql的默认隔离级别。
 解决了脏读和不可重读，但是不能解决幻读。
 幻读：当某个事务读取某个范围的数据的时候，新的事务又在该范围插入了新的记录，当之前的事务在此读取该范围内的记录时，会产生幻行。
 InnoDB存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）解决了幻读问题。
 ## SERIALIZABLE       可串行化
 强制事务串行执行，避免了幻读。
 
 
 # 事务日志
 事务要保证ACID的完整性必须依靠事务日志做跟踪
 每一个操作在真正写入数据库之前,先写入到日志文件中
 
 如要删除一行数据会先在日志文件中将此行标记为删除,但是数据库中的数据文件并没有发生变化.
 只有在(包含多个sql语句)整个事务提交后,再把整个事务中的sql语句批量同步到磁盘上的数据库文件
 
在事务引擎上的每一次写操作都需要执行**两遍**:
### 1.先写入日志文件中
写入日志文件中的**仅仅是操作过程**,而不是操作数据本身,所以速度比写数据库文件速度要快很多.
存储引擎在修改表的数据时，需要**修改其内存拷贝**，再把该修改行为持久到事务日志中，而不用持久化到数据库。事务日志持久后，内存中被修改的数据，在后台可以慢慢刷回磁盘。
事务日志采用追加方式，写日志的操作是磁盘上一小块区域内的顺序IO，而不像随机IO需要在磁盘的多个地方移动磁头，所以速度快。
### 2.然后再写入数据库文件中
写入数据库文件的操作是重做事务日志中已提交的事务操作的记录.
日志组
一般不止设置一个日志文件,一个文件写满之后使用另外一个日志文件提高服务器效率.
日志文件的日志同步到磁盘后空间会自动释放,单个日志文件不宜设置过大
如果日志文件过大mysql进程在把日志同步到数据文件的时候可能会崩溃

innodb事务日志包括redo log和undo log。redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。
undo log不是redo log的逆向过程，其实它们都算是用来恢复的日志：
1.redo log通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。
2.undo用来回滚行记录到某个版本。undo log一般是逻辑日志，根据每行记录进行记录。

一般所说的log file并不是磁盘上的物理日志文件，而是操作系统缓存中的log file




#  两阶段锁定协议
事务执行过程中  随时可以执行锁定，只有执行提交或者回滚时，才会释放锁，并且所有的锁都是同时释放的。
InnoDB根据隔离级别，在需要的时候会自动加锁。

显式锁定命令：
SELECT ...LOCK IN SHARE MODE
SELECT ... FOR UPDATE



# SET TRANSACTION ISOLATION LEVEL
设置事务隔离级别

# MVCC是一个行级锁的变种，但是很多情况下避免了加锁，开销更小。
通过保存数据在某个时间点的快照实现的，不管需要执行多长时间，每个事务看到的数据都是一致的。
不同存储引擎对MVCC的实现是不一样的，典型的有乐观并发控制和悲观并发控制。
#  InnoDB的MVCC是通过每行记录后面保存两个隐藏的列来实现的。一列保存了行创建的时间，一列保存了行的过期时间或者删除时间。
保存的不是真实的时间，而是系统的版本号。每开始一个事务，系统版本号都会自动递增。事务开始时刻的系统版本号回座位事务的版本号。

# MVCC只在REPEATABLE READ 和 READ COMMITTED两个隔离级别下工作，与其他两个隔离级别不兼容。READ UNCOMMITTED总是读取最新的数据行，而不是符合当前事务版本的数据行。SERIALIZABLE则会对所有读取的行都加锁。

在REPEATABLE READ级别下，MVCC具体是如何工作的：
#  SELECT :
InnoDB根据以下两个条件检查每一行记录：
&nbsp;1、只查找版本**早于**当前事务版本的数据行，这样可以确保事务读取的行，要么是事务开始前就存在的行，要么是事务自身插入或者修改过的。
&nbsp;2、**行的删除版本要么未定义，要么大于当前事务版本号**。这可以确保事务读取到的行，在事务开始之前未被删除。
# INSERT :
InnoDB为新插入的行添加当前系统版本号作为行版本号。
# UPDATE :
InnoDB新插入一行，保存当前版本号作为行版本号；保存当前版本号到原来的行，作为删除标识。
# DELETE :
InnoDB为删除的每一行保存当前版本号作为行删除标识。

保存这两个额外的系统版本号，可以使大多数读操作都可以不用加锁。


MyISAM是默认存储引擎（Mysql5.1前）。它基于更老的ISAM代码，但有很多有用的扩展。（注意MySQL 5.1不支持ISAM）。 每个MyISAM在磁盘上存储成三个文件，每一个文件的名字均以表的名字开始，扩展名指出文件类型。
.frm文件存储表定义；
·MYD (MYData)文件存储表的数据；
.MYI (MYIndex)文件存储表的索引。























